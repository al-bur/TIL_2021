# [210413] 알고리즘 - SWEA 1244. 최대상금

### 1. 문제설명

---


```markdown
[문제]

퀴즈 대회에 참가해서 우승을 하게 되면 보너스 상금을 획득할 수 있는 기회를 부여받는다.

우승자는 주어진 숫자판들 중에 두 개를 선택에서 정해진 횟수만큼 서로의 자리를 위치를 교환할 수 있다.

예를 들어, 다음 그림과 3, 2, 8, 8, 8 의 5개의 숫자판들이 주어지고 교환 횟수는 2회라고 하자.

처음에는 첫번째 숫자판의 3과 네 번째 숫자판의 8을 교환해서 8, 2, 8, 3, 8이 되었다.

다음으로, 두 번째 숫자판 2와 마지막에 있는 8을 교환해서 8, 8, 8, 3, 2이 되었다.

정해진 횟수만큼 교환이 끝나면 숫자판의 위치에 부여된 가중치에 의해 상금이 계산된다.

숫자판의 오른쪽 끝에서부터 1원이고 왼쪽으로 한자리씩 갈수록 10의 배수만큼 커진다.

위의 예에서와 같이 최종적으로 숫자판들이 8,8,8,3,2의 순서가 되면 88832원의 보너스 상금을 획득한다.

여기서 주의할 것은 반드시 횟수만큼 교환이 이루어져야 하고 동일한 위치의 교환이 중복되어도 된다.

다음과 같은 경우 1회의 교환 횟수가 주어졌을 때 반드시 1회 교환을 수행하므로 결과값은 49가 된다.

[입력]

가장 첫 줄은 전체 테스트 케이스의 수이다.

최대 20개의 테스트 케이스가 표준 입력을 통하여 주어진다.

각 테스트 케이스에는 숫자판의 정보와 교환 횟수가 주어진다.

숫자판의 정보는 정수형 숫자로 주어지고 최대 자릿수는 6자리이며, 최대 교환 횟수는 10번이다.

[출력]

각 테스트 케이스마다, 첫 줄에는 “#C”를 출력해야 하는데 C는 케이스 번호이다.

같은 줄에 빈 칸을 하나 사이에 두고 교환 후 받을 수 있는 가장 큰 금액을 출력한다.
```

<br>

### 2. 문제풀이

---

```python
# 선택정렬 함수
def selection_sort():
    for i in range(length[0] - 1):
        # max_idx, max_value 초기화 (i)
        max_idx = [0]
        max_value = num[i]
        for j in range(i + 1, length[0]):
            # 숫자판을 돌면서 가장 큰 값 idx, value 찾기
            if num[j] >= max_value:
                max_idx[0] = j
                max_value = num[j]
        # num[i] 보다 큰 값이 있을 때만 정렬
        if max_idx[0] > 0:
            # 위치 바꿔주고
            num[i], num[max_idx[0]] = num[max_idx[0]], num[i]
            # 변경횟수 - 1
            cnt[0] -= 1
            # 변경횟수 다 사용했으면
            if cnt[0] <= 0:
                # 함수 탈출
                return


# 변경횟수가 남았을 시 정렬된 숫자판에 같은 숫자가 있는 지 파악하기 위한 함수
# 같은 숫자가 있으면 해당 숫자들끼리만 바꿔주면 되기 때문에 정렬된 숫자판 그대로 정답으로 사용 가능
def find_same_values():
    for k in range(length[0] - 1):
        for l in range(k, length[0]):
            if num[k] == num[l]:
                # True면 되기 때문에 아무 value나 return해도 된다.
                return k, l

# 선택정렬이 끝난 후 변경횟수가 남은 상태에서 
# 숫자판에 같은 숫자까지 없다면 정렬된 숫자판에서 가장 작은 숫자 2개 ([-1][-2]) 끼리 변경해주는 함수
def remainder():
    # cnt 남은 만큼
    for _ in range(cnt[0]):
        # 바꿔준다
        num[-1], num[-2] = num[-2], num[-1]
    return num


T = int(input())
for tc in range(1, T + 1):
    str_num, str_cnt = input().split()
    # 숫자판 생성
    num = list(map(int, str_num))
    # 변경횟수 
    cnt = [int(str_cnt)]
    # 숫자판 길이
    length = [len(num)]
    # 선택 정렬 실행
    selection_sort()
    # 변경횟수가 남아있고 숫자판에 같은 수가 없으면 remainder() 함수 실행
    print('#%d %s' % (tc, ''.join(map(str, remainder() if cnt[0] > 0 and not find_same_values() else num))))
```

<br>



### 비고

---

- 10개 중에 7개 test_case만 통과하는 코드
- 풀릴때까지 계속 풀어볼 예정

