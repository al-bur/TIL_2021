# [210925] JavaScript - 함수 표현식과 함수 선언문

예전에, 함수를 정의하는 방법에 대한 글을 작성하면서, 함수 표현식과 함수 선언문이라는 방법을 소개한 적이 있다.
이전에는 간단하게 함수를 정의하는 방법에 대해서 설명했다면, 이번에는 `함수 표현식`과 `함수 선언문`에 대해서 자세하게 설명해보고자 한다.

> 함수 정의란, 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말한다. 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.


<br>

### 함수 선언문의 특징
---

먼저, 함수 선언문을 다뤄보자


**기본 모습**

```javascript
function add (x, y) {
  return x + y;
}
```

<br>

**특징**
- 표현식이 아닌 문이다.
- 함수 선언문은 함수 리터럴과 형태가 동일하다.
- 함수 선언문은 함수 이름을 생략할 수 없다.


<br>

**함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다**를 잘 참고해보자

위의 특징을 기반으로 생각해보면 함수 선언문으로 정의한 add함수는 외부에서 참조할 수가 없어야한다. 즉, 식별자가 없어서 add 함수를 호출할 수 없다는 뜻이다.
하지만, 실제로는 add로 add 함수를 호출할 수 있고 값이 제대로 나오는 것을 확인할 수 있다.

```javascript
function add (x, y) {
  return x + y;
}

add (3, 4) // 7
```


<br>

**이는 어떻게 가능한 것인가??**

add는 자바스크립트 엔진에서 암묵적으로 생성한 식별자이기 때문이다!
자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성하고 이를 가리키는 식별자를 암묵적으로 생성하고, 해당 식별자에 함수 객체를 할당해주는 것이다.

최종적으로, 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.


<br>

### 함수 표현식
---

이제 함수 표현식을 살펴보자.

함수는 `일급 객체`이다. 일급 객체이기 때문에 `값`처럼 자유롭게 사용될 수 있고 변수에 함수를 값처럼 할당할 수 있다.

이러한 함수 정의 방식을 `함수 표현식`이라 한다.

**위에서 함수 선언문으로 정의한 함수를 함수 표현식으로 바꾸어본 것이 아래의 코드이다.**

```javascript

var add  = function (x, y) {
  return x + y;
}

```


<br>

**특징**

- 무기명 함수로 작성할 수 있다


<br>

### 함수 선언문과 함수 표현식의 함수 생성시점에서의 차이
---

이제, 이번 TIL의 가장 중요한 내용을 다루려고 한다.

`함수 선언문`과 `함수 표현식`은 함수 생성시점에서 차이가 생기게되고 이로 인해, 최근에는 `함수 표현식`을 권장하고 있다.

호이스팅에 대해서 간단한 정의를 하겠다.
> 호이스팅: 밑에서 위로 끌어올린다는 의미로, 자바스크립트 엔진이 코드를 실행하기 전에, 모든 선언들을 해당 선언들이 유효한 범위에서의 최상단으로 끌어올리는 특징


```javascript

// 함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(1,2)); // 3
console.log(sub(2,1)); // TypeError: sub is not a function

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
}

```

위의 코드를 살펴보면서 `함수 표현식`과 `함수 선언문`의 함수 생성시점에 대해서 살펴보겠다.

`함수 선언문`으로 정의된 함수는 `함수 호이스팅`으로 인해 최상단으로 끌어올려지게 되고 함수 참조와 호출이 모두 가능해지게된다.
이는, 변수 호이스팅과 다른 특징이 있어서 가능한 것인데, 일반적으로, var 키워드로 인한 `변수 호이스팅` 같은 경우에는 선언과 `undefined`로 초기화 되는 과정이 먼저 이루어지고, 이후에 런타임(실행) 단계에서 값을 할당 받는다.
하지만, `함수 호이스팅`은 런타임 이전에 함수 객체가 먼저 생성되고, 자바스크립트 엔진에의해 생성된 식별자에 할당까지 완료된다. 그렇기 때문에, `함수 선언문` 이전에 호출과 참조가 가능한 것이다.

<br>

**그렇다면, 함수 표현식은 어떨까?**
`함수 선언문`과 달리 `함수 표현식`으로 함수를 정의하면 함수 호이스팅이 아니라 `변수 호이스팅`이 발생한다.
예를 들면, var 키워드로 선언된 `sub`이라는 변수가 호이스팅이되고 `undefined`로 초기화가 된다. 이 상태에서 호출을 하게 되면 `sub`은 undefined가 할당이 되어 있기 때문에 `TypeError`가 발생하게 된다. 
이후, 할당문이 실행되는 시점, 즉 런타임에 함수 표현식의 함수 리터럴이 평가되어 `함수 객체`가 된다.


<br>

**정리하자면, `함수 호이스팅`으로 `함수 선언문`이 실행되기 전에 함수를 호출할 수 있는 `함수 선언문`과 달리 `함수 표현식`은 표현식이후에 호출이 가능하다**

여담으로, `함수 호이스팅`은 함수를 호출하기 전에 반드시 함수를 선언해야한다는 규칙을 무시하므로, 많은 사람들이 함수 선언문 대신 함수 표현식을 사용할 것을 권장한다.
